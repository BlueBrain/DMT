"""A random parameter is just another parameter that can generate
random values."""

from abc import ABC, abstractmethod
import types
import inspect
import pandas as pd
from dmt.vtk.utils.descriptor import Field
from dmt.vtk.measurement.parameter import Parameter
from dmt.vtk.utils.collections import Record, take

class RandomVariate(ABC):
    """Like a Parameter, but yields random values.
    """
    label = Field(
        __name__ = "label",
        __type__ = str,
        __is_valid_value__ = lambda instance, value: ' ' not in value,
        __doc__ = """Label for the random variable generated. May be used as a
        keyword for passing parameters to measurement methods."""
    )
    value_type = Field(
        __name__ = "value_type",
        __type__ = type,
        __doc__  = """Type of the variable generated by this RandomParameter."""
    )
    def __init__(self, *args, **kwargs):
        if "label" in kwargs:
            self.label = kwargs["label"]
        
    @abstractmethod
    def values(self, *args, **kwargs):
        """Returns a generator."""
        pass

    def repr(self, value):
        """Represent value 'value' of this random variate.
        Override if you wish to."""
        assert(isinstance(value, self.value_type))
        return str(value)



class ConditionedRandomVariate(RandomVariate):
    """RandomVariate conditioned on other variables."""
    conditioning_variables = Field(
        __name__ = "conditioning_variables",
        __type__ = tuple,
        __is_valid_value__ = lambda self, ps: all(isinstance(p, Parameter) for p in ps),
        __doc__  = """Variables that determine the distribution
        of this RandomVariable."""
    )
    values = Field(
        __name__ = "values",
        __type__ =  types.FunctionType,
        __is_valid_value__ = lambda instance, v: inspect.isgeneratorfunction(v),
        __doc__ = """Yields random values of this random variable. The input
        parameters to this generator function must be values of
        the conditioning variables."""
    )
    def __init__(self, *args, **kwargs):
        """Initialize this class with a 'values' parameter, or
        implement a 'values' method in a subclass.

        Parameters
        ------------------------------------------------------------------------
        values :: self.condition_type -> value_type #method for random generation.
        """ 
        self.conditioning_variables = kwargs["conditioning_variables"]

        values = kwargs.get("values", None)
        if values is not None:
            self.__class__.values = values

        label = kwargs.get("label", None)
        if label is not None:
            self.label = label

        super(ConditionedRandomVariate, self).__init__(*args, **kwargs)

    @property
    def conditions(self):
        """..."""
        def __get_tuples(conditioning_variables):
            """..."""
            if not conditioning_variables:
                return [[]]

            head_tuples = [[(conditioning_variables[0].label, value)]
                           for value in conditioning_variables[0].values]
            tail_tuples = __get_tuples(conditioning_variables[1:])
            return [h+t for h in head_tuples for t in tail_tuples]

        for cs in __get_tuples(self.conditioning_variables):
            yield Record(**dict(cs))

    def assert_condition_is_valid(self, condition):
        """..."""
        assert(all(hasattr(condition, variable.label)
                   for variable in self.conditioning_variables))
        
    def conditioned_values(self, condition, *args, **kwargs):
        """Generate values of this RandomVariate for given conditions."""
        for value in take(kwargs.get("size", 20),
                          self.values(condition, *args, **kwargs)):
            yield pd.DataFrame({self.label: [value]},
                               index=self.index([condition]))
                    
    def index(self, conditions=None, __repr__=True):
        """A Pandas index for the provided conditions."""
        if conditions is None:
            conditions = self.conditions

        variables = [var.label for var in self.conditioning_variables]
        return pd.MultiIndex.from_tuples(
            [tuple(getattr(c, v) for v in variables) for c in conditions],
            names=variables
        )


    def sample(self, *args, condition=None, **kwargs):
        """..."""
        def __sample(condition):
            return pd.concat(list(take(
                kwargs.get("size", 20),
                self.conditioned_values(condition=condition, *args, **kwargs)
            )))

        if condition:
            return __sample(condition)

        return pd.concat([__sample(condition) for condition in self.conditions])



        

def get_conditioned_random_variate(conditioning_variables, random_variate,
                                   *args, **kwargs):
    """Creates a class instance on the fly."""
    kwargs.update(dict(conditioning_variables=conditioning_variables,
                       label=random_variate.label))

    class _ConditionedRandomVariate(ConditionedRandomVariate,
                                     random_variate.__class__):
        """..."""
        def __init__(self, *args, **kwargs):
            """..."""
            super(_ConditionedRandomVariate, self).__init__(*args, **kwargs)



    return _ConditionedRandomVariate(*args, **kwargs)
                                         
