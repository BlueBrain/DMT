"""A random parameter is just another parameter that can generate
random values."""

from abc import ABC, abstractmethod
import copy
import types
import inspect
import pandas as pd
from dmt.vtk.utils.descriptor import Field
from dmt.vtk.measurement.parameter import Parameter
from dmt.vtk.measurement.condition import Condition, ConditionGenerator
from dmt.vtk.utils.collections import Record, take
from dmt.vtk.utils.logging import Logger, with_logging
from dmt.vtk.utils.descriptor import WithFCA


class RandomVariate(WithFCA, ABC):
    """Like a Parameter, but yields random values.
    """
    label = Field(
        __name__ = "label",
        __type__ = str,
        __is_valid_value__ = lambda instance, value: ' ' not in value,
        __doc__ = """Label for the random variable generated. May be used as a
        keyword for passing parameters to measurement methods."""
    )
    value_type = Field(
        __name__ = "value_type",
        __type__ = type,
        __doc__  = """Type of the variable generated by this RandomParameter."""
    )
    def __init__(self, *args, **kwargs):
        self.logger.inform("initialize {} with kwargs: {}"\
                           .format(self.__class__.__name__, kwargs))
        super(RandomVariate, self).__init__(*args, **kwargs)

    def values(self, *args, **kwargs):
        """Returns a generator."""
        pass

    def repr(self, value):
        """Represent value 'value' of this random variate.
        Override if you wish to."""
        assert(isinstance(value, self.value_type))
        return str(value)


class ConditionedRandomVariate(RandomVariate):
    """RandomVariate conditioned on other variables."""
    condition_type = Field(
        __name__="condition_type",
        __type__=Record,
        __doc__="""Record mapping field names to their types.""",
        __examples__=[Record(layer=int, target=str)]
    )
    def __init__(self, conditions=None, *args, **kwargs):
        """Initialize this class with a 'values' parameter, or
        implement a 'values' method in a subclass.

        Parameters
        ------------------------------------------------------------------------
        label :: String
        """
        self._conditions = conditions
        super(ConditionedRandomVariate, self).__init__(*args, **kwargs)

    @property
    def conditions(self):
        """..."""
        return self._conditions

    def is_valid(self, condition_generator):
        """..."""
        fields = self.condition_type.fields
        return(all(f in condition_generator.labels for f in fields ) and
               all(issubclass(condition_generator.value_type(f),
                              self.condition_type.get(f))
                   for f in fields))

    def __with_condition_generator(self, condition_generator):
        """..."""
        instance = copy.deepcopy(self)
        instance._conditions = condition_generator
        return instance

    def __with_condition_type(self, condition_type):
        """..."""
        instance = copy.deepcopy(self)
        instance.condition_type = condition_type
        return instance

    def given(self, *conditioning_vars, reset_condition_type=False):
        """..."""
        cname = self.__class__.__name__
        if reset_condition_type:
            self.condition_type \
                = Record(**{v.label: v.value_type for v in conditioning_vars})
                
        for v in conditioning_vars:
            l = v.label
            if l not in self.condition_type.fields:
                raise AttributeError(
                    "Missing conditioning variable {} in {} instance condition_type."\
                    .format(l, cname)
                )
            if not issubclass(v.value_type, self.condition_type.get(l)):
                raise AttributeError(
                    "Unsupported type for conditioning variable {} in {} instance condition_type."\
                    .format(l, cname)
                )
        return self.__with_condition_generator(ConditionGenerator(conditioning_vars))

    @abstractmethod
    def conditioned_values(self, condition, *args, **kwargs):
        """Yield random values of this RandomVariate for given conditions.a
        """
        pass

    def sample(self, conditions=None, size=20, *args, **kwargs):
        conditions = conditions if conditions else self._conditions
        if conditions is None:
            self.logger.warn(
                "Cannot sample without condition generator 'conditions'"
            )
            return None

        if not self.is_valid(conditions):
            self.logger.warn(
                """Invalid condition generator.
                Please provide one that produces conditions of type:\n {}"""\
                .format(self.condition_type)
            )
            return None

        def __sample(condition):
            return pd.concat(
                [pd.DataFrame({self.label: [v]},index=condition.index)
                 for v in take(size, self.conditioned_values(condition))]
            )
        return pd.concat([__sample(condition) for condition in conditions])

    def transform(self,  t):
        """Transform this ConditionedRandomVariate by transforming its value
        outputs."""
        modified = copy.deepcopy(self)
        def conditioned_values(condition, *args, **kwargs):
            for v in self.conditioned_values(condition, *args, **kwargs):
                yield t.function(v)

        modified.label = t.label
        modified.conditioned_values = conditioned_values
        return modified


def get_conditioned_random_variate(conditioning_variables, random_variate,
                                   *args, **kwargs):
    """Creates a class instance on the fly."""
    kwargs.update(dict(conditioning_variables=conditioning_variables,
                       label=random_variate.label))
    name = "Conditioned{}RandomVariate".format(
        "".join(w.capitalize() for w in random_variate.label.split('_'))
    )
    T = type(name, (ConditionedRandomVariate, random_variate.__class__), {} )
    return T(*args, **kwargs)

                                         
