"""aii is Adapter, Interface, and (their) Implementations.
A validation should employ a language of the problem domain, and not be
specialized for a particular problem domain. So the validation code in a
ValidationTestCase must interface with a model through an adapter. The author
of a ValidationTestCase must mark the methods required from the Adapter with
decorators '@requiredmethod'. To use a ValidaionTestCase for a particular
model, the user must provide an adapter implmentation."""

from types import FunctionType
from abc import ABC, abstractmethod
from dmt.vtk.author import Author

class InterfaceMeta(type):
    """A metaclass to be used to create Interfaces!
    This metaclass will strip away any method implementation,
    thus enforcing a strict interface that is not allowed to have any
    methods with implementations in its body."""

    def __init__(meta, name, bases, attrs):
        """..."""
        def raise_not_implemented(function):
            """..."""
            def function_eff(*args, **kwargs):
                raise NotImplementedError

            function_eff.__doc__ = function.__doc__

        for m in attrs.keys():
            attrs[m] = raise_not_implemented(attrs[m])

        super(InterfaceMeta, meta).__init__(name, bases, attrs)


class Interface(metaclass=InterfaceMeta):
    """Abstract base class to define an Interface."""

    def __init__(self, *args, **kwargs):
        """An Interface cannot be instantiated."""
        raise Exception("""{} is an Interface.
        An Interface cannot be initialized.
        It must be implemented!!!""".format(self.__class__.__name__))

    __requiredmethods__ = []
    __implementation_registry__ = {}
    __implementation_guide__ = "Please provide implementation instructions."

    @classmethod
    def register_implementation(cls, impl):
        """Register an implementation."""
        for method in cls.__requiredmethods__:
            if not hasattr(cls, method):
                print(cls.__implementation_guide__)
                raise Exception(
                    "Unimplemented method '{}' required by interface "\
                    .format(cls.__name__)
                )
        cls.__implementation_registry__[impl.__name__] = impl

    @classmethod
    def is_implemented_by(cls, implementation):
        """Is this interface implemented by an implementation?"""
        return (hasattr(implementation, '__implemented_interface__') and
                implementation.__implemented_interface__ == cls)


def requiredmethod(method):
    """Decorator, to be used to decorate a method of a class that must
    be included in that class's AdapterInterface."""
    method.__isrequiredmethod__ = True
    return method

def adaptermethod(method):
    """Decorator, to be used to decorate a method of a class that must
    be included in that class's AdapterInterface."""
    method.__isadaptermethod__  = True
    doc = """Method defined in an Adapter Interface, will need implementation
    ----------------------------------------------------------------------------
    """
    method.__doc__ = doc + "\n" + method.__doc__
    method.__doc__ += """
    ----------------------------------------------------------------------------
    """
    return method

def reportattribute(method):
    """Decorator, to be used to decorate a method of a class that must
    must be included in that class's ReportInterface.
    Normally such a class will be a test, and ReportInterface of that
    class will specify the type of report generated by that validation.
    Validation author is free to require any method in a report,
    but we request that they provide adequate documentation to help the users
    of their validation."""
    method.__isreportattribute__ = True
    return method

def is_interface(cls):
    """Is class 'cls' an interface.
    We establish the protocol that any class derived from Interface is
    an interface."""
    return issubclass(cls, Interface)

def is_required_method(method):
    """Specify the protocol that a method is required by an interface."""
    return (isinstance(method, FunctionType) and
            getattr(method, '__isrequiredmethod__', False))


def is_adapter_method(method):
    """Specify the Protocol that an Adapter should implement a method. This
    method will be listed in an AdapterInterface."""
    return (isinstance(method, FunctionType) and
            getattr(method, '__isadaptermethod__', False))

def is_report_attribute(attr):
    """Specify the Protocol that a Report should have an attribute. This
    method will be listed a ReportInterface."""
    return getattr(attr, '__isreportattribute__')
    
def needs_adapter_interface(client_cls):
    """Specifies the protocol that a class specifies an interface.
    A class that has any method with attribute '__isadaptermethod__' set to
    'True' will be treated as specifying an interface.
    """
    return any([is_adapter_method(getattr(client_cls, method))
                for method in dir(client_cls)])
                                   
def get_interface(client_cls, name='Interface'):
    """Create an interface for a client class.
    Parameters
    ----------
    @client_cls :: type #the class that needs an interface."""
    if not needs_adapter_interface(client_cls):
        return None

    required = {m: getattr(client_cls, m) for m in dir(client_cls)
                if is_adapter_method(getattr(client_cls, m))}
    cname = client_cls.__name__
    spec = type(name, (Interface, ), required)
    spec.__requiredmethods__ = required.keys()

    msg = "{} for {} requires you to implement\n".format(name, cname)

    n = 1
    for m, mm in required.items():
        msg += "\t({}) {}: ".format(str(n), m)
        if mm.__doc__ is not None:
            msg += mm.__doc__
        msg += "\n" 
        n += 1
    spec.__implementation_guide__ = msg
    return spec

def implementation_registry(an_interface):
    """list of implementations"""
    if not is_interface(an_interface):
        raise Exception(
            "class {} is not an interface!!!".format(an_interface.__name__)
        )
    return an_interface.__implementation_registry__
            

from abc import ABCMeta, abstractmethod
class AIMeta(ABCMeta):
    """A metaclass that will add an AdapterInterface."""
    def __new__(mcs, name, bases, dct):
        print("AIMeta will create a new {} with name {}".format(mcs.__name__, name))
        cls = super(AIMeta, mcs).__new__(mcs, name, bases, dct)
        return cls

    def __init__(cls, name, bases, dct):
        print("AIMeta will initialize {} with name {}".format(cls.__name__, name))
        cls.AdapterInterface = get_interface(cls, name='AdapterInterface')

        super(AIMeta, cls).__init__(name, bases, dct)


def adapter_documentation(cls):
    """Documentation of a class that will use an adapter."""
    return "AdapterInterface"

class AdapterInterfaceBase(metaclass=AIMeta):
    """A base class for classes that will declare an adapter interface.

    Initializer
    ----------------------------------------------------------------------------
    Pass a keyword argument 'model_adapter' to set the attribute _model_adapter.
    """

    _model_adapter = None

    def __init__(self, *args, **kwargs):
        self._model_adapter = kwargs.get('model_adapter', None)

    @property
    def model_adapter(self):
        """The adapter implementation to be used."""
        if self._model_adapter is None:
            raise Exception("An Adapter for {} was not set!!!"\
                            .format(self.__class__.__name__))
        return self._model_adapter

    @model_adapter.setter
    def model_adapter(self, value):
        """Reset the adapter."""
        self._model_adapter = value

    @property
    def adapter(self):
        """Another name for model_adapter.
        'model_adapter' is awkward. We went for this long form to keep open
        the possibility of having a 'data_adapter'. But looking towards a more
        generalized approach, you may also want to be able to validated two
        models against each other. The question is what will increase the
        overall usability of this framework.

        Thus on the side of simplicity, we argue for defining a validation
        along with the data --- that is data is part of a validation's
        definition. The more general notion may be defined as a 'Comparison'.
        We can have a hierarchy, starting with 'Analysis'.

        If we choose thus, then it makes sense that 'adapter' is always a
        'model_adapter'. We do not have to change the innards -- so protected
        variable name remains '_model_adapter'.
        """
        if self._model_adapter is None:
            raise Exception("An Adapter for {} was not set!!!"\
                            .format(self.__class__.__name__))
        return self._model_adapter

    @adapter.setter
    def adapter(self, value):
        """Reset the adapter, after testing that the new value is that of a
        valid implementation."""
        if self.AdapterInterface.is_implemented_by(value):
            self._model_adapter = value
        else:
            raise ValueError("{} does not implement {} adapter's interface"\
                             .format(value, self.__class__.__name__))

    @classmethod
    def accepted_models(cls):
        """Models that this class with AdapterInterface will accept ---
        models for which at least one concrete implementation is available."""
        return set([
            get_adapted_entity(impl)
            for impl in implementation_registry(cls.AdapterInterface).values()
            if get_adapted_entity(impl) is not None
        ])


def is_interface_implementation(cls):
    """Does class 'cls' implement an interface?"""
    return getattr(cls, '__isinterfaceimplementation__', False)

def implements_interface(cls, an_interface):
    """
    Does given class implement the given interface?
    ---------------------------------------------------------------------------

    Parameters
    ---------------------------------------------------------------------------
    @cls :: type # class we want to check
    @an_interface <: Interface #subclass of Interface
    ---------------------------------------------------------------------------

    Protocol
    ---------------------------------------------------------------------------
    A class 'cls' implements the interface 'an_interface'

    Return
    ---------------------------------------------------------------------------
    @type bool
    """
    return (hasattr(cls, '__implemented_interface__') and
            an_interface.__implemented_interface__ == an_interface)

def implementation_guide(an_interface):
    """Instructions on how to implement an interface"""
    if not is_interface(an_interface):
        raise Exception("{} is not an interface!!!"\
                        .format(an_interface.__name__))
    return an_interface.__implementation_guide__


def get_required_methods(cls):
    return getattr(cls, '__requiredmethods__', [])

#and now the implementations
#def interface_implementation(an_interface):
def implementation(an_interface,
                   adapted_entity=None,
                   reported_entity=None):
    """A class decorator to declare that a class implements an interface, which
    may either adapt a Model or Data-object to a Validation, or may implement a
    reporter class.
    ---------------------------------------------------------------------------
    Parameters
    ---------------------------------------------------------------------------
    @an_interface :: Interface# mostly generated with an appropriate decorator
    @adapted_entity :: MeasurableSystem# model / data that was adapted
    @reported_entity :: Analysis #in most cases that I can think of!
    ---------------------------------------------------------------------------
    Protocol
    ---------------------------------------------------------------------------
    A class 'cls' is an interface implementation
    if cls.__isinterfaceimplementation__ == True
    ---------------------------------------------------------------------------
    """
    if not issubclass(an_interface, Interface):
        raise Exception("{} is not an Interface".format(an_interface.__name__))

    def effective(cls):
        """Effective class"""
        if not hasattr(cls, 'author'):
            #ISSUE A WARNING HERE with the following message
            print("Interface {} implementation {} should attribute its author"\
                  .format(an_interface.__name__, cls.__name__))
            cls.author = Author.anonymous
            print("Here we will assume that the author is Anonymous\n",
                  cls.author)
        an_interface.register_implementation(cls)
        cls.__isinterfaceimplementation__ = True
        cls.__implemented_interface__ = an_interface
        if adapted_entity is not None and reported_entity is not None:
            raise ValueError("""
            Only one of 'adapted_entity', 'reported_entity'
            may be passed as an argument!!!
            """)
        if adapted_entity is not None:
            cls.__adapted_entity__ = adapted_entity
        if reported_entity is not None:
            cls.__reported_entity__ = reported_entity
        return cls
    return effective

def get_implementations(an_interface):
    """all the implementations"""
    if not isinstance(an_interface, Interface):
        raise Exception("{} is not an Interface!!!"\
                        .format(an_interface.__name__))
    return an_interface.__implementation_registry__
        
def get_adapted_entity(impl):
    """Get models implemented by an implementation.
    We assume that one implementation will adapt only one model type."""
    return getattr(impl, '__adapted_entity__', None)

                



